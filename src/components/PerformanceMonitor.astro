---
// Advanced Performance Monitoring Component
// Tracks Core Web Vitals and other performance metrics

interface Props {
  enableAnalytics?: boolean;
  enableConsole?: boolean;
  enableRealUserMonitoring?: boolean;
}

const { 
  enableAnalytics = true, 
  enableConsole = false, 
  enableRealUserMonitoring = true 
} = Astro.props;
---

<script>
  // Advanced Performance Monitoring
  class PerformanceMonitor {
    constructor(options = {}) {
      this.enableAnalytics = options.enableAnalytics ?? true;
      this.enableConsole = options.enableConsole ?? false;
      this.enableRUM = options.enableRealUserMonitoring ?? true;
      this.metrics = {};
      
      this.init();
    }
    
    init() {
      if (typeof window === 'undefined') return;
      
      // Wait for page load
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => this.startMonitoring());
      } else {
        this.startMonitoring();
      }
    }
    
    startMonitoring() {
      this.monitorCoreWebVitals();
      this.monitorResourceTiming();
      this.monitorUserInteractions();
      this.monitorErrors();
      
      if (this.enableRUM) {
        this.monitorRealUserMetrics();
      }
    }
    
    monitorCoreWebVitals() {
      // LCP (Largest Contentful Paint)
      new PerformanceObserver((entryList) => {
        const entries = entryList.getEntries();
        const lastEntry = entries[entries.length - 1];
        
        this.metrics.lcp = lastEntry.startTime;
        this.logMetric('LCP', lastEntry.startTime);
        this.sendToAnalytics('lcp', lastEntry.startTime);
      }).observe({ entryTypes: ['largest-contentful-paint'] });
      
      // FID (First Input Delay)
      new PerformanceObserver((entryList) => {
        const entries = entryList.getEntries();
        entries.forEach(entry => {
          const fid = entry.processingStart - entry.startTime;
          this.metrics.fid = fid;
          this.logMetric('FID', fid);
          this.sendToAnalytics('fid', fid);
        });
      }).observe({ entryTypes: ['first-input'] });
      
      // CLS (Cumulative Layout Shift)
      let clsValue = 0;
      new PerformanceObserver((entryList) => {
        const entries = entryList.getEntries();
        entries.forEach(entry => {
          if (!entry.hadRecentInput) {
            clsValue += entry.value;
            this.metrics.cls = clsValue;
            this.logMetric('CLS', clsValue);
            this.sendToAnalytics('cls', clsValue);
          }
        });
      }).observe({ entryTypes: ['layout-shift'] });
      
      // FCP (First Contentful Paint)
      new PerformanceObserver((entryList) => {
        const entries = entryList.getEntries();
        entries.forEach(entry => {
          this.metrics.fcp = entry.startTime;
          this.logMetric('FCP', entry.startTime);
          this.sendToAnalytics('fcp', entry.startTime);
        });
      }).observe({ entryTypes: ['first-contentful-paint'] });
      
      // TTFB (Time to First Byte)
      new PerformanceObserver((entryList) => {
        const entries = entryList.getEntries();
        entries.forEach(entry => {
          const ttfb = entry.responseStart - entry.requestStart;
          this.metrics.ttfb = ttfb;
          this.logMetric('TTFB', ttfb);
          this.sendToAnalytics('ttfb', ttfb);
        });
      }).observe({ entryTypes: ['navigation'] });
    }
    
    monitorResourceTiming() {
      new PerformanceObserver((entryList) => {
        const entries = entryList.getEntries();
        entries.forEach(entry => {
          if (entry.entryType === 'resource') {
            const resourceMetrics = {
              name: entry.name,
              duration: entry.duration,
              size: entry.transferSize,
              type: entry.initiatorType
            };
            
            this.logMetric('Resource', resourceMetrics);
            
            // Track slow resources
            if (entry.duration > 3000) {
              this.sendToAnalytics('slow_resource', resourceMetrics);
            }
          }
        });
      }).observe({ entryTypes: ['resource'] });
    }
    
    monitorUserInteractions() {
      let interactionCount = 0;
      let lastInteractionTime = Date.now();
      
      const trackInteraction = () => {
        interactionCount++;
        const timeSinceLastInteraction = Date.now() - lastInteractionTime;
        lastInteractionTime = Date.now();
        
        this.metrics.interactions = {
          count: interactionCount,
          timeSinceLast: timeSinceLastInteraction
        };
        
        this.sendToAnalytics('user_interaction', {
          count: interactionCount,
          timeSinceLast: timeSinceLastInteraction
        });
      };
      
      // Track clicks, scrolls, and form interactions
      document.addEventListener('click', trackInteraction, { passive: true });
      document.addEventListener('scroll', trackInteraction, { passive: true });
      document.addEventListener('submit', trackInteraction, { passive: true });
    }
    
    monitorErrors() {
      // JavaScript errors
      window.addEventListener('error', (event) => {
        const errorData = {
          message: event.message,
          filename: event.filename,
          lineno: event.lineno,
          colno: event.colno,
          stack: event.error?.stack
        };
        
        this.logMetric('Error', errorData);
        this.sendToAnalytics('js_error', errorData);
      });
      
      // Promise rejections
      window.addEventListener('unhandledrejection', (event) => {
        const errorData = {
          reason: event.reason,
          promise: event.promise
        };
        
        this.logMetric('Unhandled Promise Rejection', errorData);
        this.sendToAnalytics('promise_rejection', errorData);
      });
    }
    
    monitorRealUserMetrics() {
      // Page load time
      window.addEventListener('load', () => {
        const loadTime = performance.now();
        this.metrics.pageLoadTime = loadTime;
        this.logMetric('Page Load Time', loadTime);
        this.sendToAnalytics('page_load_time', loadTime);
        
        // Navigation timing
        const navigation = performance.getEntriesByType('navigation')[0];
        if (navigation) {
          const navMetrics = {
            domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
            domInteractive: navigation.domInteractive - navigation.fetchStart,
            loadComplete: navigation.loadEventEnd - navigation.fetchStart
          };
          
          this.metrics.navigation = navMetrics;
          this.logMetric('Navigation Timing', navMetrics);
          this.sendToAnalytics('navigation_timing', navMetrics);
        }
      });
      
      // Memory usage (if available)
      if ('memory' in performance) {
        setInterval(() => {
          const memory = performance.memory;
          const memoryMetrics = {
            used: memory.usedJSHeapSize,
            total: memory.totalJSHeapSize,
            limit: memory.jsHeapSizeLimit
          };
          
          this.metrics.memory = memoryMetrics;
          this.sendToAnalytics('memory_usage', memoryMetrics);
        }, 30000); // Check every 30 seconds
      }
    }
    
    logMetric(name, value) {
      if (this.enableConsole) {
        console.log(`ðŸ“Š ${name}:`, value);
      }
    }
    
    sendToAnalytics(metric, value) {
      if (!this.enableAnalytics) return;
      
      // Send to Google Analytics 4
      if (typeof gtag !== 'undefined') {
        gtag('event', 'performance_metric', {
          metric_name: metric,
          metric_value: value,
          page_location: window.location.href,
          page_title: document.title
        });
      }
      
      // Send to custom analytics endpoint
      this.sendToCustomAnalytics(metric, value);
    }
    
    sendToCustomAnalytics(metric, value) {
      // Send to your own analytics endpoint
      fetch('/api/analytics/performance', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          metric,
          value,
          url: window.location.href,
          timestamp: Date.now(),
          userAgent: navigator.userAgent
        })
      }).catch(error => {
        // Silently fail for analytics
        console.debug('Analytics send failed:', error);
      });
    }
    
    getMetrics() {
      return this.metrics;
    }
    
    // Performance budget checking
    checkPerformanceBudget() {
      const budget = {
        lcp: 2500, // 2.5 seconds
        fid: 100,  // 100ms
        cls: 0.1,  // 0.1
        fcp: 1800, // 1.8 seconds
        ttfb: 600  // 600ms
      };
      
      const violations = [];
      
      Object.entries(budget).forEach(([metric, threshold]) => {
        if (this.metrics[metric] && this.metrics[metric] > threshold) {
          violations.push({
            metric,
            actual: this.metrics[metric],
            threshold,
            difference: this.metrics[metric] - threshold
          });
        }
      });
      
      if (violations.length > 0) {
        this.logMetric('Performance Budget Violations', violations);
        this.sendToAnalytics('performance_budget_violation', violations);
      }
      
      return violations;
    }
  }
  
  // Initialize performance monitoring
  const performanceMonitor = new PerformanceMonitor({
    enableAnalytics: {enableAnalytics},
    enableConsole: {enableConsole},
    enableRealUserMonitoring: {enableRealUserMonitoring}
  });
  
  // Expose for debugging
  window.performanceMonitor = performanceMonitor;
  
  // Check performance budget after page load
  window.addEventListener('load', () => {
    setTimeout(() => {
      performanceMonitor.checkPerformanceBudget();
    }, 5000);
  });
</script> 